#include "arduino_secrets.h"
/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/97bbf00e-9235-433b-8237-d1bc3ce8123e 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  float distance;
  bool led;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/
#include <WiFiS3.h>
#include <NTPClient.h>   // For getting time from an NTP server
#include <WiFiUdp.h>     // Required dependency for NTPClient
#include <RTC.h>         // For the onboard Real-Time Clock
#include "arduino_secrets.h"
const char* ssid = SECRET_SSID;      // WiFi network SSID
const char* password = SECRET_OPTIONAL_PASS;  // WiFi network password

#include "thingProperties.h"
#include <LiquidCrystal_I2C.h>

int trigPin = 10;
int echoPin = 11;
int button = 2;
int buttonState = 0;


// --- GLOBAL OBJECTS & VARIABLES ---
WiFiUDP ntpUDP; // UDP object for NTP communication

const long utcOffsetInSeconds = 2 * 60 * 60;  // UTC+2
// Setup the NTP client to get time from a public server.
// UTC offset is 0. Update interval is set high because we control updates manually.
NTPClient timeClient(ntpUDP, "pool.ntp.org", utcOffsetInSeconds, 86400000);
 
 // Variable to hold the current Wi-Fi connection status
int wifiStatus = WL_IDLE_STATUS; 

LiquidCrystal_I2C lcd(0x27, 16, 2);
 
 void setup() {
   Serial.begin(9600);
   while (!Serial);
   WiFi.begin(ssid, password);
   connectWiFi();
   lcd.init();
   lcd.backlight();

   pinMode(trigPin, OUTPUT);
   pinMode(echoPin, INPUT);
   pinMode(button, INPUT);
 
   delay(1500); 
 
  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  
  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
 */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
}

void loop() {
  ArduinoCloud.update();
  // Your code here \
  // Get the current time at the start of the loop for consistent timing
  unsigned long currentMillis = millis();

  // --- Task 1: Periodically check Wi-Fi and re-sync the clock ---
  // This happens once per hour.
  checkConnectionAndSync(currentMillis);

  // --- Task 2: Print the current time to the Serial Monitor ---
  // This happens once per second.
  


  buttonState = digitalRead (button);
  if (buttonState == HIGH){
    printTime(currentMillis);
  }
  else{
    onDistanceChange();
  }

  // --- Add other non-blocking tasks here ---
  // For example, check for a button press or read a sensor.
  // Because there is no delay(), the loop is very responsive.
}


// --- HELPER FUNCTIONS ---

/**
 * @brief Manages the periodic check of Wi-Fi and time synchronization.
 * @param currentMillis The timestamp from the start of the current loop().
 */


/*
  Since Led is READ_WRITE variable, onLedChange() is
  executed every time a new value is received from IoT Cloud.
*/

void onLedChange()  {
  // Add your code here to act upon Led change
}

/*
  Since Distance is READ_WRITE variable, onDistanceChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onDistanceChange()  {
  // Add your code here to act upon Distance change
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);

  //Distance Calculation
  float distance1 = pulseIn (echoPin, HIGH);
  distance1 = distance1/58;
  Serial.print(distance1);
  Serial.println(" cm");
  LCD_i2c("Distance:", "", distance1);
  
  
  
}

void checkConnectionAndSync(unsigned long currentMillis) {
  static unsigned long lastSyncTime = 0;
  const unsigned long syncInterval = 3600000UL; // 1 hour (in milliseconds)

  if (currentMillis - lastSyncTime >= syncInterval) {
    wifiStatus = WiFi.status();
    if (wifiStatus != WL_CONNECTED) {
      Serial.println("Wi-Fi disconnected. Attempting to reconnect...");
      WiFi.disconnect();
      connectWiFi(); // Try to establish a new connection
    }
    
    // If connected (or reconnected), sync the time
    if (wifiStatus == WL_CONNECTED) {
      syncRTCWithNTP();
    } else {
      Serial.println("Still no Wi-Fi. Continuing with RTC time.");
    }
    lastSyncTime = currentMillis; // Reset the timer
  }
}

/**
 * @brief Prints the current RTC time to the Serial monitor once per second.
 * @param currentMillis The timestamp from the start of the current loop().
 */

void printTime(unsigned long currentMillis) {
  static unsigned long lastPrintTime = 0;
  const unsigned long printInterval = 1000UL; // 1 second (in milliseconds)

  if (currentMillis - lastPrintTime >= printInterval) {
    RTCTime currentTime;
    RTC.getTime(currentTime); // Get the time from the hardware RTC
    
    // Format the time into a character array (more memory-efficient than String)
    char timeString[20];
    snprintf(timeString, sizeof(timeString), "%02d:%02d:%02d",
             (currentTime.getHour()+2), currentTime.getMinutes(), currentTime.getSeconds());
    
    // Print the formatted time efficiently
    Serial.print("Current RTC Time: ");
    Serial.println(timeString);
    LCD_i2c ("", timeString, 0);
    
    
    
    lastPrintTime = currentMillis; // Reset the timer
  }
}

/**
 * @brief Handles the initial Wi-Fi connection logic.
 */
void connectWiFi() {
  Serial.print("Connecting to SSID: ");
  Serial.println(ssid);
  
  WiFi.begin(ssid, password);
  
  int attempts = 0;
  const int maxAttempts = 20; // Try for 10 seconds (20 * 500ms)
  
  wifiStatus = WiFi.status();
  while (wifiStatus != WL_CONNECTED && attempts < maxAttempts) {
    delay(500); // Use a small delay here as it's a one-time setup task
    Serial.print(".");
    wifiStatus = WiFi.status(); // Update status inside the loop
    attempts++;
  }
  
  if (wifiStatus == WL_CONNECTED) {
    Serial.println("\nWiFi connected successfully.");
    Serial.print("IP Address: ");
    Serial.println(WiFi.localIP());
  } else {
    Serial.println("\nWiFi connection failed after 10 seconds.");
  }
}

/**
 * @brief Fetches time from NTP server and updates the RTC.
 */
void syncRTCWithNTP() {
  Serial.println("Updating RTC with NTP time...");
  // Force the NTP client to update its time value from the server
  if (timeClient.forceUpdate()) {
    unsigned long epochTime = timeClient.getEpochTime();
    
    // Create an RTCTime object from the epoch time and set the hardware RTC
    RTCTime ntpTime(epochTime);
    RTC.setTime(ntpTime);
    
    Serial.println("RTC updated successfully.");
  } else {
    Serial.println("Failed to fetch time from NTP server.");
  }
}
